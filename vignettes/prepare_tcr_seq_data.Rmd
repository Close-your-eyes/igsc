---
title: "prepare_tcr_seq_data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{prepare_tcr_seq_data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  cache = F,
  cache.lazy = F,
  eval = F,
  comment = "#>"
)
options(knitr.kable.NA = '', width = 60)
```

```{r setup1}
install.packages("tidyverse")
install.packages("randomNames")
install.packages("BiocManager")
install.packages("parallel")
install.packages("pbapply")
BiocManager::install("Biostrings")
BiocManager::install("protR")
```

```{r setup, message=F,}
library(igsc)
library(tidyverse)
```

```{r,include=F}
vdj_path <- file.path(dirname(getwd()), "ignore_folder", "VDJ")
```

Prepare a folder with sub-folder of your samples.
```{r}
# vdj_path is the directory on your disk and may contain sub-folders of different samples
list.files(vdj_path)
```

Each sub-folder must contain the 6 files from the cr output which are required to prepare a data frame as in the procedure below.
Some modifications may be possible putting the functionality of downstream functions at risk though.
```{r}
list.files(file.path(vdj_path, "Pat3_rep1_blood"))
```

## Read raw files from cr output

Read the files one by one and modify one or the other column name. Some operations are optional, others are necessary to join the data frames below.
```{r }
consensus_annotations <- dplyr::bind_rows(lapply(list.files(vdj_path, "consensus_annotations\\.csv", recursive = T, full.names = T), function(x) {
  read.csv(x, sep = ",") %>% dplyr::mutate(sample = basename(dirname(x)))
})) %>%
  dplyr::rename("clonotype_id_cr" = clonotype_id, "consensus_id_cr" = consensus_id) %>%
  dplyr::mutate(consensus_id_cr = str_extract(consensus_id_cr, "[:digit:]{1,}$")) %>%
  dplyr::mutate(clonotype_id_cr = str_extract(clonotype_id_cr, "[:digit:]{1,}"))

clonotypes <- dplyr::bind_rows(lapply(list.files(vdj_path, "clonotypes\\.csv", recursive = T, full.names = T), function(x) {
  read.csv(x, sep = ",") %>% dplyr::mutate(sample = basename(dirname(x)))
})) %>%
  dplyr::rename("clonotype_id_cr" = clonotype_id) %>%
  dplyr::mutate(clonotype_id_cr = str_extract(clonotype_id_cr, "[:digit:]{1,}"))

contig_annotations <- dplyr::bind_rows(lapply(list.files(vdj_path, "filtered_contig_annotations\\.csv", recursive = T, full.names = T), function(x) {
  read.csv(x, sep = ",") %>% dplyr::mutate(sample = basename(dirname(x)))
})) %>%
  dplyr::rename("Barcode" = barcode, "contiq_id_cr" = contig_id, "clonotype_id_cr" = raw_clonotype_id, "consensus_id_cr" = raw_consensus_id) %>%
  dplyr::mutate(Barcode = str_replace(Barcode, "-1$", ""), contiq_id_cr = str_extract(contiq_id_cr, "[:digit:]{1,}$")) %>%
  dplyr::mutate(consensus_id_cr = str_extract(consensus_id_cr, "[:digit:]{1,}$")) %>%
  dplyr::mutate(clonotype_id_cr = str_extract(clonotype_id_cr, "[:digit:]{1,}"))

consensus_fasta <- dplyr::bind_rows(lapply(list.files(vdj_path, "consensus\\.fasta$", recursive = T, full.names = T), function(x) {
  stack(protr::readFASTA(x)) %>% dplyr::mutate(sample = basename(dirname(x)))
})) %>%
  dplyr::rename("consensus_seq_cr" = values) %>%
  tidyr::separate(ind, into = c("clonotype_id_cr", "temp", "consensus_id_cr"), sep = "_") %>%
  dplyr::select(-temp) %>%
  dplyr::mutate(consensus_id_cr = consensus_id_cr) %>%
  dplyr::mutate(clonotype_id_cr = str_extract(clonotype_id_cr, "[:digit:]{1,}$"))

consensus_ref_fasta <- dplyr::bind_rows(lapply(list.files(vdj_path, "concat_ref\\.fasta$", recursive = T, full.names = T), function(x) {
  stack(protr::readFASTA(x)) %>% dplyr::mutate(sample = basename(dirname(x)))
})) %>%
  dplyr::rename("ref_seq_cr" = values) %>%
  tidyr::separate(ind, into = c("clonotype_id_cr", "temp1", "temp2", "ref_seq_cr.id"), sep = "_") %>%
  dplyr::select(-c(temp1, temp2)) %>%
  dplyr::mutate(ref_seq_cr.id = ref_seq_cr.id) %>%
  dplyr::mutate(clonotype_id_cr = str_extract(clonotype_id_cr, "[:digit:]{1,}"))

contig_fasta <- dplyr::bind_rows(lapply(list.files(vdj_path, "filtered_contig\\.fasta$", recursive = T, full.names = T), function(x) {
  stack(protr::readFASTA(x)) %>% dplyr::mutate(sample = basename(dirname(x)))
})) %>%
  dplyr::rename("contiq_seq_cr" = values) %>%
  tidyr::separate(ind, into = c("Barcode", "temp", "contiq_id_cr"), sep = "_") %>%
  dplyr::select(-c(temp)) %>%
  dplyr::mutate(Barcode = str_replace(Barcode, "-1$", "")) %>%
  dplyr::mutate(contiq_id_cr = contiq_id_cr)
```

## Process to long data frame

Join the data frames. The only source for cell-barcodes are the contig-files.
```{r }
consensus_data <-
  consensus_annotations %>%
  dplyr::full_join(consensus_fasta, by = c("clonotype_id_cr" = "clonotype_id_cr", "consensus_id_cr" = "consensus_id_cr", "sample" = "sample")) %>%
  dplyr::full_join(consensus_ref_fasta, by = c("clonotype_id_cr" = "clonotype_id_cr", "consensus_id_cr" = "ref_seq_cr.id", "sample" = "sample"))

contig.data <-
  contig_annotations %>%
  dplyr::full_join(contig_fasta, by = c("contiq_id_cr" = "contiq_id_cr", "Barcode" = "Barcode", "sample" = "sample"))

contig_data_barcodes <-
  contig.data %>%
  dplyr::distinct(sample, clonotype_id_cr, Barcode)
```

Make one final data frame in long format.
```{r }
cl_long <-
  dplyr::left_join(consensus_data, contig_data_barcodes) %>%
  dplyr::mutate(clonotype_id_cr = paste0(sample, "_", clonotype_id_cr)) %>%
  dplyr::rename("V_cr" = v_gene, "D_cr" = d_gene, "J_cr" = j_gene, "C_cr" = c_gene, "CDR3.aa_cr" = cdr3, "CDR3.nt_cr" = cdr3_nt)
```

## Additional columns

Even though cr annotates VDJ chain, we may repeat that ourselves as well. Also this brings the IMGT nomenclature into our data frame. For that we have to prepare a respective data frame from the data available on IMGTs website.
This may be done with the igsc:imgt_tcr_segment_prep(). More easily: The respective data frames for human and mouse are included in this package, with data downloaded Oct-2021 from IMGT.

```{r }
# optional:
# imgt_ref <- igsc::imgt_tcr_segment_prep()
# see ?igsc::imgt_tcr_segment_prep()
imgt_ref <- readRDS(system.file("extdata", "IMGT_ref/human/hs.rds", package = "igsc"))
# for mouse:
#imgt_ref <- readRDS(system.file("extdata", "IMGT_ref/mouse/mm.rds", package = "igsc"))

# first, match allele names by smallest string distance
V_matches <- sapply(unique(cl_long$V_cr), function(x) {
  ref_al <- imgt_ref$Allele[which(grepl(stringr::str_extract(x, "^[:alpha:]{1,}[:digit:]{1,}"), imgt_ref$Allele))]
  dists <- adist(x, ref_al, ignore.case = T)
  min_val <- min(dists)
  return(unique(ref_al[which(dists == min_val)]))
})
J_matches <- sapply(unique(cl_long$J_cr), function(x) {
  ref_al <- imgt_ref$Allele[which(grepl(stringr::str_extract(x, "^[:alpha:]{1,}[:digit:]{1,}"), imgt_ref$Allele))]
  dists <- adist(x, ref_al, ignore.case = T)
  min_val <- min(dists)
  return(unique(ref_al[which(dists == min_val)]))
})
cl_long$V_imgt <- V_matches[cl_long$V_cr]
cl_long$J_imgt <- J_matches[cl_long$J_cr]

# then resolve allele-groups for which there are multiple alleles in IMGT
V_unique <-
  cl_long %>%
  dplyr::distinct(consensus_seq_cr, V_imgt, clonotype_id_cr)

V_unique$V_imgt <- unlist(pbapply::pblapply(1:nrow(V_unique), function(x) {
  als <- unlist(V_unique$V_imgt[x])
  if (length(als) == 1) {
    return(unname(als))
  } else {
    seq <- V_unique$consensus_seq_cr[x]
    refs <- imgt_ref[which(imgt_ref$Allele %in% als),]
    max.ind <- which.max(Biostrings::pairwiseAlignment(subject = Biostrings::DNAString(seq), pattern = Biostrings::DNAStringSet(refs[,"seq.nt"]), type = "local", scoreOnly = T))
    max.ind <- sample(1:length(max.ind), 1) # if multiple matches with equal score, pick one randomly
    return(refs[max.ind,"Allele"])
  }
}))

J_unique <-
  cl_long %>%
  dplyr::distinct(consensus_seq_cr, J_imgt, clonotype_id_cr)

J_unique$J_imgt <- unlist(pbapply::pblapply(1:nrow(J_unique), function(x) {
  als <- unlist(J_unique$J_imgt[x])
  if (length(als) == 1) {
    return(unname(als))
  } else {
    seq <- J_unique$consensus_seq_cr[x]
    refs <- imgt_ref[which(imgt_ref$Allele %in% als),]
    max.ind <- which.max(Biostrings::pairwiseAlignment(subject = Biostrings::DNAString(seq), pattern = Biostrings::DNAStringSet(refs[,"seq.nt"]), type = "local", scoreOnly = T))
    max.ind <- sample(1:length(max.ind), 1) # if multiple matches with equal score, pick one randomly
    return(refs[max.ind,"Allele"])
  }
}))

# join
cl_long <-
  cl_long %>%
  dplyr::select(-c(J_imgt, V_imgt)) %>%
  dplyr::left_join(V_unique, by = c("consensus_seq_cr", "clonotype_id_cr")) %>%
  dplyr::left_join(J_unique, by = c("consensus_seq_cr", "clonotype_id_cr"))

```

With the randomNames packages you may give your clonotypes a catchy name, as an alternative to e.g. "clonotype1001". The sampling from randomNames does not work perfect though, so we use a custom loop to avoid duplicate names.
```{r }
# in this case we trust the clonotype assignment from cr but one could also check that
cls <- unique(cl_long$clonotype_id_cr)
names <- c()
for (i in seq_along(cls)) {
  name <- trimws(randomNames::randomNames(1, which.names = "first"))
  while(name %in% names) {
    name <- trimws(randomNames::randomNames(1, which.names = "first"))
  }
  names <- c(names, name)
}
cls <- stats::setNames(object = names, nm = cls)
cl_long$clonotype_name <- cls[cl_long$clonotype_id_cr]
```


## Make a wide data frame

Prepare a data frame in the wide format. Long or wide format may be useful in different scenarios.
```{r }
# https://github.com/tidyverse/tidyr/issues/1114
collapse.fun <- function(x) {
  paste(x,collapse = ",")
}
cl_wide <-
  cl_long %>%
  dplyr::select(chain, Barcode, clonotype_id_cr, sample, CDR3.nt_cr, CDR3.aa_cr, V_cr, J_cr, C_cr, consensus_seq_cr, ref_seq_cr, V_imgt, J_imgt, clonotype_name) %>%
  tidyr::pivot_wider(names_from = chain, values_from = c(CDR3.nt_cr, CDR3.aa_cr, V_cr, J_cr, C_cr, consensus_seq_cr, ref_seq_cr, V_imgt, J_imgt), values_fn = collapse.fun)
cl_wide <- as.data.frame(cl_wide)
```
```{r  include=F}
#cl_wide <- readRDS("clonotype_data.rds")[["wide"]]
```
```{r }
# test if every name is unique to clonotype_id_cr
check <-
  cl_wide %>%
  dplyr::distinct(clonotype_name, CDR3.nt_cr_TRA, CDR3.nt_cr_TRB, clonotype_id_cr) %>%
  dplyr::group_by(clonotype_name) %>%
  dplyr::summarise(levels.per.clonotype.name = n()) %>%
  dplyr::ungroup() %>%
  dplyr::pull(levels.per.clonotype.name)
all(check == 1)
```

Save the processed clonotype data. The wide format may be used to create meta-data columns in the Seurat Object. That way the phenotype data are complemented with clonotype information which are then readily available e.g. as color code on a dimension reduction plot or so.
```{r }
cl <- list(wide = cl_wide, long = cl_long)
saveRDS(cl, "clonotype_data.rds")
```


```{r, include=F}
cl <- readRDS("clonotype_data.rds")
imgt_ref <- readRDS(system.file("extdata", "IMGT_ref/human/hs.rds", package = "igsc"))
```

## Align TCR sequencing data with IMGT references and obtain the V(D)J-range

Now everything is set up to systematically align IMGT TCR reference gene segments to our sequencing data of TCRs.
```{r}
# lets find an expanded clonotype_name
top_expanded_clonotypes <- sort(table(cl[["wide"]]$clonotype_name), decreasing = T)
head(top_expanded_clonotypes)
# use the TCR that has been detected in most single cell transcriptomes
# check the documentation of align_imgt_ref_to_TCR_seq to understand the inputs
align_list_TRA <- igsc::align_imgt_ref_to_TCR_seq(chain = "TRA", TCR = setNames(names(top_expanded_clonotypes)[1], "clonotype_name"), cl = cl, imgt_ref = imgt_ref)
align_list_TRB <- igsc::align_imgt_ref_to_TCR_seq(chain = "TRB", TCR = setNames(names(top_expanded_clonotypes)[1], "clonotype_name"), cl = cl, imgt_ref = imgt_ref)
```

The output of align_imgt_ref_to_TCR_seq contains several plots and sequence information.
```{r, fig.width=8, fig.height=4}
names(align_list_TRA)
# this plot shows how many different unique sequences existed in cl_long; source column is consensus_seq_cr
# in different cells (single cell transcriptomes) the consensus_seq_cr may differ slightly but still the TCR is grouped into one clonotype
# sometimes there are irrelevant sequence differences at the beginning or the end, which do not include the V(D)J-region
# if there are at least 2 different ones the consensus is used for further processing
align_list_TRA[[1]][[1]]

# the consensus sequences is available at the second index
align_list_TRA[[2]][[1]]

# at indices 3 and 4 are plots (and the respective data frames) for V(D)JC or V(D)J alignments
# these plots are made with a custom function igsc::MultiplePairwiseAlignmentsToOneSubject()
# names on the y-axis show the pattern name its the full length in nt
# number-annotations in the plot indicate the first and last nt of the alignment of the respective pattern
# vertical dashed lines indicate the lower and upper limit of all patterns aligned to the subject
align_list_TRA[[3]][[1]][[2]]

# the last sub-index contains the lower and upper limit as integers
align_list_TRA[[3]][[1]][[5]]

# the last index of align_list_TRA contains the V(D)J-sequence of your TCR (sequence between the vertical lines of align_list_TRA[[4]][[2]])
# if the alignment plots are as expected this sequence may be used for further processing
align_list_TRA[[5]][[1]]
```

## Concanetate a TCR cassette

The obtained V(D)J-sequences can then be used to concatenate the complete TCR (attach the constant gene segment) or a whole expression cassette with additional elements like
a P2A element, restriction sites, etc. Below one possible cassette is created. A fasta file with cassette elements is included in this package.
```{r}
tcr_cassette_elements <- protr::readFASTA(system.file("extdata", "TCR_cassette_elements.fasta", package = "igsc"))

# concatenate
concat_seq <- toupper(paste0(tcr_cassette_elements[["NotI_site"]], # left restriction site
                             tcr_cassette_elements[["Kozak_sequence_noATG"]], # eukaryotic translation initiation
                             align_list_TRB[["V.to.J.TCR.seq"]], # TRB V->J chain
                             substr(tcr_cassette_elements[["mTRBC2_Ser57Cys_STOPcodon_removed"]],
                                    2,
                                    nchar(tcr_cassette_elements[["mTRBC2_Ser57Cys_STOPcodon_removed"]])), # mTRBC, see info below
                             tcr_cassette_elements[["gsg_linker"]], # linker that provides flexibility for more efficient cleavage
                             tcr_cassette_elements[["P2A_element"]], # a cleavable linker
                             align_list_TRA[["V.to.J.TCR.seq"]], # TRA V->J chain
                             substr(tcr_cassette_elements[["mTRAC_Thr48Cys"]],
                                    2,
                                    nchar(tcr_cassette_elements[["mTRAC_Thr48Cys"]])), #mTRAC, see info below
                             tcr_cassette_elements[["EcoRI_site"]]) # right restriction site
                      )
```

Please note, that the the original sequences of constant chains have been altered. One codon each has been changed to a Cysteine (Ser57Cys, Thr48Cys) for TRB and TRA, respectively. This increases stability of the chain pairing. Moreover, in this example of human TCRs constant chain are taken from mouse which has several reasons. It descreases mispairing with (if present) endogenous TCR and positive transductants may easily be identified by a mAb for mTCRb (clone H57-597).




